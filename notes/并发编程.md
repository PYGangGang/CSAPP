# 并发编程

**什么是并发**

---

还记得刚毕业找工作的时候（也几乎就是刚开始自学计算机的时候），关于并发和并行，我背了不少的八股文；什么并行是一种特殊的并发，并行就是多核，广义并发是 CPU 的时分复用之类的。虽然都对，但是这里还是写一下我对《CS: APP》里概念的理解，加深印象：

> 并发（concurrency）是指多个逻辑控制流的开始到结束，在时间上存在交集的现象
> 
> 并行（parallel）是指在并发的前提下，多个逻辑控制流，在时间上存在重叠的现象（在多个计算单元上）。

这些只是概念理解，接下来是真正实现并发的几种常见方式：

* 多进程
* I / O 复用
* 多线程

我们用并发编程的最常见场景，服务器来讲解。当然，也有纯粹的 SIMD 指令、GPU 并行计算等，这咱就不讨论了。

**基于进程的并发编程**

---

基于进程的并发实际上就是将调度的任务彻底交给了内核，使用 fork, exec, waitpid 等系统调用，创建新的进程执行一些程序。这里带来了很明显的优势，父子进程共享文件描述符、各进程间完全不会互相影响，我们不用太关心调度。

**基于多进程的并发服务器**

我们在主进程用一个 passive socket 来监听请求，每当请求到来，在主进程里建立连接后，将连接描述符“交给”子进程，由子进程负责响应。注意事项标注在代码中：

```cpp
#include "csapp.h" // 太多头文件和自定义包装函数了，我就不自己打了

void echo(int connfd); // 往 connfd 里写回显的函数，之前的笔记里有实现

void sigchld_handler(int sig) {
    while (waitpid(-1, 0, WNOHANG) > 0) {
        // DONOTHING
        // 注意这里用了 -1，因为信号不会排队，我们每次收到 SIGCHLD 都要尽可能多地回收
    }
    return;
}

int main(int argc, char **argv) {
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    // 检查参数
    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }

    // 必须显式回收子进程；
    // 虽然说主进程结束过后，子进程会被自动回收
    // 但是对于这样一个服务器的场景，我们不知道什么时候主进程会结束，很容易 OOM
    Signal(SIGCHLD, sigchld_handle);
    listenfd = Open_listenfd(argv[1]);

    // here we go =)
    while(1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
        if (Fork() == 0) {
            Close(listenfd); // 子进程用不了监听描述符了
            echo(connfd);
            Close(connfd); // 此时父子进程的文件描述符表都有一项指向这个 socket
            exit(0);
        }
        Close(connfd); // 子进程用完了 connfd，父进程也必须关闭，不然仍有引用不会删除
    }
}
```

多进程的缺点也非常明显，进程不共享用户地址空间，必须使用进程间通信（IPC, Inter-Process Communication)；希望之后有时间来补充一下常见的方法：信号、socket、管道、命名管道、FIFO、系统 V 共享内存、系统 V 信号量。

**基于 I/O 多路复用的并发编程**

---

《CS: APP》直接就用一个服务器例子开始讲了，我一开始看得比较懵，让我们先解释一下概念。I/O 多路复用（I/O multiplexing）是指一种可以让内核通知进程，某个设备有数据可读的机制，Linux 上 select, poll, epoll 都可以实现。此处用 select 的读操作举例。

首先考虑之前的 echo 服务器模型，我们给它加上能够响应本地命令的功能，那么我们实际上需要处理两个 I/O 事件：

* listenfd 是否有新的建立连接请求
* stdin 是否有新的输入

显然，我们可以从 accept 开始一直阻塞到完成响应，但是这个时候我们就完全响应不了命令行了；而使用 I/O 多路复用我们就可以这样实现：select 函数会阻塞在等待一个 connfd 集合有新的请求到来，一旦有一个或多个 fd 可以读了，才会返回到当前进程。select 的形式如下：

```cpp
#include <sys/select.h>

int select(int n, fd_set *fdset, NULL, NULL, NULL);

FD_ZERO(fd_set *fdset); // 清空 fdset 里的所有位
FD_CLR(int fd, fd_set *fdset); // 清空 fdset 里 fd 对应的位
FD_SET(int fd, fd_set *fdset); // 在 fdset 里加入 fd
FD_ISSET(int fd, fd_set *fdset); // 在 fdset 里的 fd 可读了吗？
```

在准备好 fdset （一个标记 fd 的位向量，用以上四个宏操作）后，select 会一直阻塞直到这个集合里至少有一个描述符可读；select 会修改 fdset 指向的 fd_set，将其填充为可读 fd 的集合（所以得注意保存原始描述符集合）。很简单地，我们就可以写出以下 echo 服务器代码：

```cpp
#include "csapp.h"
void echo(int connfd);
void command(void);

int main(int argc, char **argv) 
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    fd_set read_set, ready_set;

    if (argc != 2) {
	fprintf(stderr, "usage: %s <port>\n", argv[0]);
	exit(0);
    }
    listenfd = Open_listenfd(argv[1]);

    FD_ZERO(&read_set);              // 先准备一个空地集合
    FD_SET(STDIN_FILENO, &read_set); // 将 stdin 填进去
    FD_SET(listenfd, &read_set);     // 将 listenfd 填进去

    while (1) {
	ready_set = read_set;
	Select(listenfd+1, &ready_set, NULL, NULL, NULL); // 阻塞直到有 IO
	if (FD_ISSET(STDIN_FILENO, &ready_set)) // 如果是 stdin 的，我们调用 command 执行指令
	    command();
	if (FD_ISSET(listenfd, &ready_set)) { // 如果是 listenfd 的，我们建立新的 connfd 并响应
            clientlen = sizeof(struct sockaddr_storage); 
	    connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
	    echo(connfd); /* Echo client input until EOF */
	    Close(connfd);
	}
    }
}

void command(void) {
    char buf[MAXLINE];
    if (!Fgets(buf, MAXLINE, stdin))
	exit(0); /* EOF */
    printf("%s", buf); // 假设就打印一下命令
}
```

这里有一个很明显的问题，如果 accept 了某个连接，那会一直响应到客户端结束连接，这之间也是无法响应任何东西的，但是好歹解决了我们听多个 IO 的希望。

**基于 I/O 多路复用的并发事件驱动服务器**

I/O 多路复用可以用作 event-driven 的基础。我们将逻辑控制流抽象为一个有限状态机，当一个输入事件（此处为 I/O）的发生，就推动这个状态机变化。那么我们可以将 echo 服务器（不带命令行）抽象为以下状态机：

```cpp
输入事件：“描述符 i 准备好可读了”           转移：“从描述符 i 读一个文本行”
                         ____________________   
                        |                    |
                        |                    \/
                    状态：“等待描述符 i 准备好可读”
```

详细的代码看：[echoservers.c](../codes/concurrent_servers/echoserver.c)，此处讲一下思想：

* 定义一个数据结构 pool 来装所有的需要监听的 fd
  * 很明显，此处我们需要监听 listenfd 以建立新的连接、监听 connfd 以响应请求
* 首先用 init_pool() 初始化 pool，将唯一的 listenfd 放进去
* 进入经典服务器死循环，开头调用 select 阻塞等待（此时只有一个 listenfd）
  * 当 select 返回时，我们首先判断 listenfd 上有没有新连接请求
    * 若有，则用 add_client() 在 pool 里创建并加入一个 connfd
  * 其次用 check_clients() 检查 pool 里的所有 connfd 是否有新请求来
    * 若有，则 echo() 一行
    * 若读 connfd EOF 了，则 close connfd 并从 pool 里把它删了

基于 I/O 多路复用的并发编程还有很多拓展，希望能够补充：reactor, proactor 模型。

**基于线程的并发编程**

---


